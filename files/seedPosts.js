// Seed data — 12 initial posts for the Post Management System

export const SEED_POSTS = [
  {
    id: "post-001",
    title: "Getting Started with React Hooks",
    author: "Piyush Sharma",
    content: `React Hooks revolutionized the way we write React components. Introduced in React 16.8, hooks allow you to use state and other React features in functional components, eliminating the need for class components in most cases.\n\nThe most commonly used hooks are useState, useEffect, and useContext. useState allows you to add local state to functional components. useEffect lets you perform side effects — like data fetching, subscriptions, or DOM manipulation — after the component renders.\n\nCustom hooks are one of the most powerful patterns in React. By extracting stateful logic into a custom hook, you can reuse that logic across multiple components without introducing unnecessary nesting. For example, a useLocalStorage hook can abstract the complexity of reading and writing to localStorage.\n\nBest practices when working with hooks include always calling hooks at the top level of your component (not inside loops or conditionals), using the dependency array in useEffect carefully to avoid infinite re-renders, and grouping related state with useReducer when state logic becomes complex.`,
    tags: ["react", "hooks", "javascript", "frontend"],
    createdAt: "2025-01-05T09:00:00Z",
    updatedAt: "2025-01-05T09:00:00Z",
  },
  {
    id: "post-002",
    title: "Mastering CSS Grid Layout",
    author: "Aisha Patel",
    content: `CSS Grid is one of the most powerful layout systems available in CSS. Unlike Flexbox, which is one-dimensional, Grid allows you to work in two dimensions — rows and columns — simultaneously.\n\nThe grid container is defined using display: grid. You then define the structure using grid-template-columns and grid-template-rows. The fr unit is particularly useful as it represents a fraction of the available space in the grid container.\n\nGrid areas allow you to name sections of your layout and place items into them using the grid-area property. This makes complex layouts highly readable. For responsive designs, you can combine Grid with the repeat() and minmax() functions to create auto-filling grids that reflow naturally at different screen sizes.\n\nOne of the most useful patterns is repeat(auto-fill, minmax(280px, 1fr)) which creates as many columns as will fit, each at least 280px wide. This eliminates the need for media queries in many card-based layouts.`,
    tags: ["css", "grid", "layout", "frontend"],
    createdAt: "2025-01-08T11:30:00Z",
    updatedAt: "2025-01-08T11:30:00Z",
  },
  {
    id: "post-003",
    title: "TypeScript Best Practices for Large Applications",
    author: "James Okafor",
    content: `TypeScript adds static typing to JavaScript, catching potential errors at compile time rather than runtime. For large applications, this is invaluable — it makes refactoring safer, improves IDE support, and serves as living documentation.\n\nOne of the most important practices is to avoid using 'any' as a type. When you use 'any', you lose all the benefits of TypeScript. Instead, use 'unknown' for values whose types you're not sure about, which forces you to narrow the type before use.\n\nUtility types like Partial<T>, Required<T>, Pick<T, K>, and Omit<T, K> are incredibly powerful for deriving new types from existing ones without code duplication. Generics allow you to write flexible, reusable code while maintaining type safety.\n\nFor large teams, establishing a consistent style guide for TypeScript is essential: deciding on interface vs type aliases, how to handle null/undefined, and when to use type assertions. ESLint with typescript-eslint can enforce these standards automatically.`,
    tags: ["typescript", "javascript", "best-practices", "architecture"],
    createdAt: "2025-01-12T14:00:00Z",
    updatedAt: "2025-01-14T08:20:00Z",
  },
  {
    id: "post-004",
    title: "Introduction to Tailwind CSS",
    author: "Piyush Sharma",
    content: `Tailwind CSS is a utility-first CSS framework that provides low-level utility classes for building custom designs directly in your HTML. Unlike Bootstrap, which gives you pre-designed components, Tailwind gives you building blocks.\n\nThe philosophy is that instead of writing custom CSS, you compose small, single-purpose utility classes. For example, instead of creating a .card class with padding, border-radius, and shadow, you'd write class="p-6 rounded-xl shadow-lg". This keeps your styles co-located with your markup.\n\nOne common concern is class bloat — HTML elements with long class strings. However, Tailwind's @apply directive lets you extract repeated patterns into custom component classes when needed. The Tailwind config file allows deep customization of your design system: custom colors, spacing scales, breakpoints, and more.\n\nThe JIT (Just-In-Time) engine, now the default, generates only the CSS you actually use, resulting in tiny production builds. Combined with PurgeCSS strategies built into the framework, Tailwind sites often have smaller CSS bundles than traditional approaches.`,
    tags: ["tailwind", "css", "frontend", "design-system"],
    createdAt: "2025-01-15T10:00:00Z",
    updatedAt: "2025-01-15T10:00:00Z",
  },
  {
    id: "post-005",
    title: "Understanding JavaScript Promises and Async/Await",
    author: "Mei Lin",
    content: `Asynchronous JavaScript can be confusing at first, but Promises and async/await make it much more manageable. A Promise represents a value that may not be available yet but will be resolved at some point in the future.\n\nPromises have three states: pending, fulfilled, and rejected. You chain .then() for success handling and .catch() for error handling. Promise.all() allows you to run multiple promises in parallel and wait for all of them to complete. Promise.race() resolves or rejects as soon as any one of the input promises does.\n\nAsync/await is syntactic sugar over Promises that makes asynchronous code look synchronous. The async keyword marks a function as asynchronous, and await pauses execution until the awaited promise resolves. Always wrap await calls in try/catch blocks to handle potential rejections gracefully.\n\nA common pitfall is awaiting promises inside loops sequentially when they could run in parallel. Instead of awaiting each iteration, collect the promises and await them with Promise.all() for better performance.`,
    tags: ["javascript", "async", "promises", "es6"],
    createdAt: "2025-01-18T13:45:00Z",
    updatedAt: "2025-01-18T13:45:00Z",
  },
  {
    id: "post-006",
    title: "React Router v6: Complete Guide",
    author: "Aisha Patel",
    content: `React Router v6 introduced several important changes from v5. The most significant is the replacement of Switch with Routes, and the use of nested routes with relative paths.\n\nRoute definitions are now more declarative and easier to nest. The element prop replaces the component and render props. Nested routes are defined as children of parent routes, and the Outlet component renders nested route content in the parent layout.\n\nThe useNavigate hook replaces useHistory for programmatic navigation. useParams, useSearchParams, and useLocation are still available for accessing URL information. The Link and NavLink components work similarly to v5, with NavLink receiving an automatic active class when its href matches the current URL.\n\nLayout routes are a powerful pattern in v6 — a parent route with no path that renders a shared layout (like a sidebar or navbar) with an Outlet for its children. This keeps layout code DRY and makes the route structure explicit.`,
    tags: ["react", "routing", "react-router", "spa"],
    createdAt: "2025-01-22T09:30:00Z",
    updatedAt: "2025-01-25T16:00:00Z",
  },
  {
    id: "post-007",
    title: "State Management: Context API vs Redux",
    author: "James Okafor",
    content: `Choosing the right state management solution is crucial for React applications. For many apps, React's built-in Context API combined with hooks is more than sufficient. For large applications with complex state interactions, Redux (or Redux Toolkit) may be the better choice.\n\nContext API works great for: theme toggling, authentication state, language preferences, and other global data that doesn't change frequently. It's simple to set up and doesn't require external libraries. However, Context is not optimized for high-frequency updates — every consumer re-renders when the context value changes.\n\nRedux excels at: complex state logic, time-travel debugging with Redux DevTools, and applications with many components accessing the same data. Redux Toolkit significantly reduces boilerplate compared to classic Redux, with createSlice, createAsyncThunk, and RTK Query.\n\nZustand and Jotai are modern alternatives worth considering. Zustand is simple, unopinionated, and performant. Jotai takes an atomic approach similar to Recoil. The right choice depends on your team's familiarity and your application's specific needs.`,
    tags: ["react", "state-management", "context", "redux"],
    createdAt: "2025-01-28T14:20:00Z",
    updatedAt: "2025-01-28T14:20:00Z",
  },
  {
    id: "post-008",
    title: "Building Accessible Web Applications",
    author: "Mei Lin",
    content: `Web accessibility (a11y) ensures that websites are usable by people with disabilities. This includes users who rely on screen readers, keyboard navigation, or other assistive technologies. Building accessible applications is not just good ethics — it's often legally required and improves UX for everyone.\n\nThe foundation of accessibility is semantic HTML. Using the right HTML elements for their intended purpose — buttons for actions, links for navigation, headings for structure — gives browsers and assistive technologies the information they need to work correctly.\n\nARIA (Accessible Rich Internet Applications) attributes fill gaps where HTML semantics aren't sufficient. aria-label provides an accessible name for elements without visible text. aria-describedby associates an element with descriptive text. aria-live announces dynamic content changes to screen reader users.\n\nFocus management is critical for custom interactive components like modals and dropdowns. When a modal opens, focus should move into it; when it closes, focus should return to the triggering element. The :focus-visible CSS pseudo-class lets you show focus indicators only for keyboard users, without affecting mouse users.`,
    tags: ["accessibility", "a11y", "html", "ux"],
    createdAt: "2025-02-01T11:00:00Z",
    updatedAt: "2025-02-01T11:00:00Z",
  },
  {
    id: "post-009",
    title: "Performance Optimization in React",
    author: "Piyush Sharma",
    content: `React applications can suffer from performance issues as they grow. Understanding when and why components re-render is key to optimizing performance. React re-renders a component whenever its state or props change, and also when its parent re-renders.\n\nReact.memo wraps a functional component and prevents it from re-rendering unless its props have changed. useMemo memoizes expensive computed values so they're not recalculated on every render. useCallback memoizes functions to prevent child components from re-rendering unnecessarily.\n\nCode splitting with React.lazy and Suspense allows you to split your bundle into smaller chunks that are loaded on demand. This is especially useful for large applications where users may never visit certain routes or use certain features.\n\nThe React DevTools Profiler is an invaluable tool for identifying performance bottlenecks. It shows you which components rendered, how long they took, and why they re-rendered. Before optimizing, always profile first — premature optimization can make code harder to read without meaningful gains.`,
    tags: ["react", "performance", "optimization", "memo"],
    createdAt: "2025-02-05T10:30:00Z",
    updatedAt: "2025-02-07T09:00:00Z",
  },
  {
    id: "post-010",
    title: "Git Workflow Best Practices for Teams",
    author: "Aisha Patel",
    content: `A well-defined Git workflow is essential for team collaboration. The two most popular workflows are Git Flow (with main, develop, feature, release, and hotfix branches) and Trunk-Based Development (where all developers commit frequently to main).\n\nFor most modern teams, Trunk-Based Development with feature flags is recommended. Short-lived feature branches (1–2 days at most) reduce merge conflicts and keep integration continuous. Feature flags allow incomplete features to be merged but hidden from users until ready.\n\nCommit messages matter more than most developers realize. Following the Conventional Commits specification (feat:, fix:, chore:, docs:, refactor:, etc.) makes your git history readable and enables automated changelog generation with tools like semantic-release.\n\nCode review culture significantly affects code quality. Effective reviews focus on logic, edge cases, and maintainability — not just style (use a linter for that). Setting clear expectations for review turnaround times prevents reviews from becoming bottlenecks in the development process.`,
    tags: ["git", "workflow", "collaboration", "devops"],
    createdAt: "2025-02-08T14:00:00Z",
    updatedAt: "2025-02-08T14:00:00Z",
  },
  {
    id: "post-011",
    title: "Introduction to REST API Design",
    author: "James Okafor",
    content: `Designing a good REST API requires thoughtful planning. REST (Representational State Transfer) is an architectural style that uses HTTP methods and status codes to represent actions and outcomes. Well-designed APIs are intuitive, consistent, and versioned.\n\nResource naming should use nouns, not verbs: /users not /getUsers. Use plural nouns for collections (/posts) and singular nouns or IDs for specific resources (/posts/123). HTTP methods convey the action: GET reads, POST creates, PUT/PATCH updates, DELETE removes.\n\nHTTP status codes must be used correctly. 200 OK for successful reads, 201 Created for successful creation, 400 Bad Request for validation errors, 401 Unauthorized for missing authentication, 403 Forbidden for insufficient permissions, 404 Not Found for missing resources, and 500 Internal Server Error for server-side failures.\n\nAPI versioning prevents breaking changes from affecting existing clients. Include the version in the URL (/api/v1/posts) or in request headers. Always provide migration guides and deprecation notices before removing API versions.`,
    tags: ["api", "rest", "backend", "http"],
    createdAt: "2025-02-10T09:00:00Z",
    updatedAt: "2025-02-10T09:00:00Z",
  },
  {
    id: "post-012",
    title: "CSS Custom Properties and Design Tokens",
    author: "Mei Lin",
    content: `CSS Custom Properties (also called CSS variables) are a powerful feature that enables dynamic, themeable stylesheets. Unlike Sass variables which are compiled away, CSS variables are live in the browser and can be changed at runtime with JavaScript.\n\nDesign tokens are the visual atoms of your design system — colors, spacing values, font sizes, border radii. Defining these as CSS custom properties creates a single source of truth that's easily maintainable. When your brand color changes, you update one variable.\n\nThe real power comes with theming. By defining your design tokens in :root and overriding them in a [data-theme="dark"] selector, you can implement dark mode with minimal code. JavaScript can read and write CSS custom properties with getPropertyValue and setProperty.\n\nInheriting and scoping custom properties is uniquely powerful. A CSS variable defined on a parent element is inherited by all its children, allowing component-level theming. This makes building themeable design systems much more elegant than traditional approaches.`,
    tags: ["css", "design-tokens", "theming", "variables"],
    createdAt: "2025-02-12T11:30:00Z",
    updatedAt: "2025-02-12T11:30:00Z",
  },
];
